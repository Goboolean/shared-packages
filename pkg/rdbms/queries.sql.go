// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package rdbms

import (
	"context"
	"database/sql"
)

const checkStockExist = `-- name: CheckStockExist :one
SELECT EXISTS(SELECT 1 FROM stock_meta WHERE hash = (?))
`

func (q *Queries) CheckStockExist(ctx context.Context, hash string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkStockExist, hash)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAccessInfo = `-- name: CreateAccessInfo :exec
INSERT INTO store_log (stock_hash, status) VALUES (?, ?)
`

type CreateAccessInfoParams struct {
	StockHash string
	Status    string
}

func (q *Queries) CreateAccessInfo(ctx context.Context, arg CreateAccessInfoParams) error {
	_, err := q.db.ExecContext(ctx, createAccessInfo, arg.StockHash, arg.Status)
	return err
}

const getAllStockMetaList = `-- name: GetAllStockMetaList :many
SELECT hash, stock_name, symbol, description, product_type, exchange, location FROM stock_meta
`

func (q *Queries) GetAllStockMetaList(ctx context.Context) ([]StockMetum, error) {
	rows, err := q.db.QueryContext(ctx, getAllStockMetaList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StockMetum
	for rows.Next() {
		var i StockMetum
		if err := rows.Scan(
			&i.Hash,
			&i.StockName,
			&i.Symbol,
			&i.Description,
			&i.ProductType,
			&i.Exchange,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockMeta = `-- name: GetStockMeta :one
SELECT hash, stock_name, symbol, description, product_type, exchange, location FROM stock_meta WHERE hash = (?)
`

func (q *Queries) GetStockMeta(ctx context.Context, hash string) (StockMetum, error) {
	row := q.db.QueryRowContext(ctx, getStockMeta, hash)
	var i StockMetum
	err := row.Scan(
		&i.Hash,
		&i.StockName,
		&i.Symbol,
		&i.Description,
		&i.ProductType,
		&i.Exchange,
		&i.Location,
	)
	return i, err
}

const getStockMetaWithPlatform = `-- name: GetStockMetaWithPlatform :one
SELECT hash, stock_name, symbol, description, product_type, exchange, location, platform, identifier FROM stock_meta JOIN stock_platform ON stock_meta.hash = stock_platform.stock_hash WHERE stock_hash = (?)
`

type GetStockMetaWithPlatformRow struct {
	Hash        string
	StockName   string
	Symbol      string
	Description sql.NullString
	ProductType string
	Exchange    string
	Location    string
	Platform    string
	Identifier  string
}

func (q *Queries) GetStockMetaWithPlatform(ctx context.Context, stockHash string) (GetStockMetaWithPlatformRow, error) {
	row := q.db.QueryRowContext(ctx, getStockMetaWithPlatform, stockHash)
	var i GetStockMetaWithPlatformRow
	err := row.Scan(
		&i.Hash,
		&i.StockName,
		&i.Symbol,
		&i.Description,
		&i.ProductType,
		&i.Exchange,
		&i.Location,
		&i.Platform,
		&i.Identifier,
	)
	return i, err
}

const insertNewStockMeta = `-- name: InsertNewStockMeta :exec
INSERT INTO stock_meta (hash, stock_name, symbol, description, product_type, exchange, location) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertNewStockMetaParams struct {
	Hash        string
	StockName   string
	Symbol      string
	Description sql.NullString
	ProductType string
	Exchange    string
	Location    string
}

func (q *Queries) InsertNewStockMeta(ctx context.Context, arg InsertNewStockMetaParams) error {
	_, err := q.db.ExecContext(ctx, insertNewStockMeta,
		arg.Hash,
		arg.StockName,
		arg.Symbol,
		arg.Description,
		arg.ProductType,
		arg.Exchange,
		arg.Location,
	)
	return err
}

const insertNewStockPlatformMeta = `-- name: InsertNewStockPlatformMeta :exec
INSERT INTO stock_platform (platform, identifier, stock_hash) VALUES (?, ?, ?)
`

type InsertNewStockPlatformMetaParams struct {
	Platform   string
	Identifier string
	StockHash  string
}

func (q *Queries) InsertNewStockPlatformMeta(ctx context.Context, arg InsertNewStockPlatformMetaParams) error {
	_, err := q.db.ExecContext(ctx, insertNewStockPlatformMeta, arg.Platform, arg.Identifier, arg.StockHash)
	return err
}
